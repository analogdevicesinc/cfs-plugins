/* Copyright 2023 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// Simplified version of hello world example from
// https://github.com/tensorflow/tflite-micro/tree/main/tensorflow/lite/micro/examples/hello_world

// Needed for sin() and fabsf()
#include <math.h>

#include "adi_initialize.h"
#include <sys/platform.h>
#include <sys/adi_core.h>
#include <stdio.h>

// Standard TfLite includes 
#include "tensorflow/lite/core/c/common.h"
#include "tensorflow/lite/micro/micro_interpreter.h"
#include "tensorflow/lite/micro/micro_log.h"
#include "tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "tensorflow/lite/micro/micro_profiler.h"
#include "tensorflow/lite/micro/recording_micro_interpreter.h"
#include "tensorflow/lite/micro/system_setup.h"
#include "tensorflow/lite/schema/schema_generated.h"

// ADI Generated model header
#include "hello_world_model_f32.hpp"

int RunFloat32Model() {
  const tflite::Model* model = ::tflite::GetModel(hello_world_model_f32);
  TFLITE_CHECK_EQ(model->version(), TFLITE_SCHEMA_VERSION);

  // Call op resolver function provided by ADI generated file to avoid
  // having to identify which operators are used by the model. 
  tflite::MicroMutableOpResolver<HELLO_WORLD_MODEL_F32_NUM_OPERATORS> op_resolver;
  TF_LITE_ENSURE_STATUS(adi_resolve_ops_hello_world_model_f32(op_resolver));

  // Arena size just a round number. The exact arena usage can be determined
  // using the RecordingMicroInterpreter.
  constexpr int kTensorArenaSize = 3000;
  uint8_t tensor_arena[kTensorArenaSize];

  tflite::MicroInterpreter interpreter(model, op_resolver, tensor_arena,
                                       kTensorArenaSize);
  TF_LITE_ENSURE_STATUS(interpreter.AllocateTensors());

  // Check if the predicted output is within a small range of the
  // expected output
  float epsilon = 0.05f;
  constexpr int kNumTestValues = 4;
  float golden_inputs[kNumTestValues] = {0.f, 1.f, 3.f, 5.f};
  bool pass = 0;
  int fails = 0;

  // Set dimensions [1,1] for input
  interpreter.input(0)->dims->data[0] = 1;
  interpreter.input(0)->dims->data[1] = 1;

  for (int i = 0; i < kNumTestValues; ++i) {
    interpreter.input(0)->data.f[0] = golden_inputs[i];
    TF_LITE_ENSURE_STATUS(interpreter.Invoke());
    float y_pred = interpreter.output(0)->data.f[0];
    float y_calc = sin(golden_inputs[i]);
    pass = fabsf(y_calc - y_pred) < epsilon;
    if (!pass)
      fails++;
    MicroPrintf("Test %d %s: pred=%f calc=%f", i, pass ? "passed" : "failed", (double)y_pred, (double)y_calc);
  }

  return fails;
}

int main(void) {

    /**
   * Initialize managed drivers and/or services that have been added to
   * the project.
   * @return zero on success
   */
    adi_initComponents();

  int fails = 0;
  tflite::InitializeTarget();
  fails += RunFloat32Model();
  MicroPrintf("Done - %s\n", fails ? "Failures" : "Success");
  while(1)
     ; /* idle loop */
  
}
