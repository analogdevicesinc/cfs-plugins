<%
/**
 * Copyright (c) 2025 Analog Devices, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// Return the UART Baud rate.
function getUartBaud() {
  return getPeriConfigValue(it.instance, "BAUD", "115200");
}

// Return the UART clock source enum.
function getUartClock() {
  const clock = getPeripheralClockSetting(it.instance, it.mux, it.clock_default);
  let clock_enum = "MXC_UART_APB_CLK";
  switch (clock) {
    case "AOD_CLK":
      clock_enum = "MXC_UART_AOD_CLK";
      break;
    case "ERFO":
      clock_enum = "MXC_UART_ERFO_CLK";
      break;
    case "ERTCO":
      clock_enum = "MXC_UART_ERTCO_CLK";
      break;
    case "EXT":
    case "EXT_CLK1":
    case "EXT_CLK2":
      clock_enum = "MXC_UART_EXT_CLK";
      break;
    case "INRO":
      clock_enum = "MXC_UART_INRO_CLK";
      break;
    case "IBRO":
    case "7MCLK":
      clock_enum = "MXC_UART_IBRO_CLK";
      break;
    case "APBCLK":
    case "PCLK":
      clock_enum = "MXC_UART_APB_CLK";
      break;
  }
  return clock_enum;
}

// Return the Data Size setting.
function getUARTDataSize() {
  return getPeriConfigValue(it.instance, "CHAR_SIZE", "8");
}

// Return the Stop Bits setting.
function getUARTStopBits() {
  let stopBits = getPeriConfigValue(it.instance, "STOP_BITS", "1");
  return stopBits === "1" ? "MXC_UART_STOP_1" : "MXC_UART_STOP_2";
}

// Return the Flow Ctrl setting.
function getUARTFlowCtrl() {
  // The logic is complicated here to deal with both old- and new-style UART
  // instances.
  let flow_params = "MXC_UART_FLOW_DIS";
  let setting = getPeriConfigValue(it.instance, "HW_FLOW_CTRL", "DISABLED");
  const rts_thresh = getPeriConfigValue(it.instance, "RTS_THRESH", "1");
  setting = getPeriConfigValue(it.instance, "RTSDC_LP_FDM", setting);
  switch (setting) {
    case "DISABLED":
      break;
    case "DEASSERT_ON_FULL":
      flow_params = "MXC_UART_FLOW_EN";
      break;
    case "DEASSERT_ON_THRESHOLD":
      flow_params = "MXC_UART_FLOW_EN";
      break;
    case "FLOW_POL_0":
      flow_params = "MXC_UART_FLOW_EN_LOW";
      break;
    case "FLOW_POL_1":
      flow_params = "MXC_UART_FLOW_EN_HIGH";
      break;
  }
  flow_params += ", " + rts_thresh;
  return flow_params;
}

// Return the Parity setting.
function getUARTParity() {
  // The logic is complicated here to deal with both old- and new-style UART
  // instances.
  let parity = "MXC_UART_PARITY_DISABLE";
  const setting = getPeriConfigValue(it.instance, "PARITY", "DISABLED");
  const level = getPeriConfigValue(it.instance, "PARITY_LEVEL", "0s");
  const md = getPeriConfigValue(it.instance, "PARITY_MD", null);
  switch (setting) {
    case "DISABLED":
      break;
    case "ODD":
      if (level === "1s" || md === "MARK") {
        parity = "MXC_UART_PARITY_ODD_1";
      } else {
        parity = "MXC_UART_PARITY_ODD_0";
      }
      break;
    case "EVEN":
      if (level === "1s" || md === "MARK") {
        parity = "MXC_UART_PARITY_EVEN_1";
      } else {
        parity = "MXC_UART_PARITY_EVEN_0";
      }
      break;
    case "MARK":
      if (level === "1s") {
        parity = "MXC_UART_PARITY_MARK_1";
      } else {
        parity = "MXC_UART_PARITY_MARK_0";
      }
      break;
    case "SPACE":
      if (level === "1s") {
        parity = "MXC_UART_PARITY_SPACE_1";
      } else {
        parity = "MXC_UART_PARITY_SPACE_0";
      }
      break;
  }
  return parity;
}

// Return the Null Modem setting.
function getUARTNullModem() {
  let nullModem = getPeriConfigValue(it.instance, "NULL_MODEM", "NULL_MODEM");
  return nullModem === "NULL_MODEM" ? "1" : "0";
}

// Return the DMA TX setting.
function getUARTDmaTx() {
  return getPeriConfigValue(it.instance, "TRANSMIT_DMA_ENABLE", "FALSE") === "TRUE";
}

// Return the DMA RX setting.
function getUARTDmaRx() {
  return getPeriConfigValue(it.instance, "RECEIVE_DMA_ENABLE", "FALSE") === "TRUE";
}

// Return the interrupt mask for any enabled interrupts.
function getUartIntMask() {
  let ie_table;
  if (it.datamodel.Name === "MAX32657" || it.datamodel.Name === "MAX32658") {
    ie_table = [
      { ctrl: "RX_FRAME_ERROR_IE", value: "MXC_F_UART_INTEN_RX_FERR" },
      { ctrl: "RX_PARTY_ERROR_IE", value: "MXC_F_UART_INTEN_RX_PAR" },
      { ctrl: "CTS_IE",            value: "MXC_F_UART_INTEN_CTS_EV" },
      { ctrl: "RX_OVERRUN_IE",     value: "MXC_F_UART_INTEN_RX_OV" },
      { ctrl: "RX_THD_IE",         value: "MXC_F_UART_INTEN_RX_THD" },
      { ctrl: "TX_ONE_BYTE_IE",    value: "MXC_F_UART_INTEN_TX_OB" },
      { ctrl: "TX_HALF_EMPTY_IE",  value: "MXC_F_UART_INTEN_TX_THD" },
      { ctrl: "RX_FULL_IE",        value: "MXC_F_UART_INTEN_RX_FULL" }
    ];
  } else if (it.datamodel.Name === "MAX32650" || it.datamodel.Name === "MAX32660" || it.datamodel.Name === "MAX32666") {
    ie_table = [
      { ctrl: "RX_FRAME_ERROR_IE", value: "MXC_F_UART_INT_EN_RX_FRAME_ERROR" },
      { ctrl: "RX_PARTY_ERROR_IE", value: "MXC_F_UART_INT_EN_RX_PARITY_ERROR" },
      { ctrl: "CTS_IE",            value: "MXC_F_UART_INT_EN_CTS" },
      { ctrl: "RX_OVERRUN_IE",     value: "MXC_F_UART_INT_EN_RX_OVERRUN" },
      { ctrl: "RX_THD_IE",         value: "MXC_F_UART_INT_EN_RX_FIFO_LVL" },
      { ctrl: "TX_ONE_BYTE_IE",    value: "MXC_F_UART_INT_EN_TX_FIFO_AE" },
      { ctrl: "TX_THD_IE",         value: "MXC_F_UART_INT_EN_TX_FIFO_LVL" },
      { ctrl: "BREAK_IE",          value: "MXC_F_UART_INT_EN_BREAK" },
      { ctrl: "RX_TO_IE",          value: "MXC_F_UART_INT_EN_RX_TO" },
      { ctrl: "LAST_BREAK_IE",     value: "MXC_F_UART_INT_EN_LAST_BREAK" }
    ];
  } else {
    ie_table = [
      { ctrl: "RX_FRAME_ERROR_IE", value: "MXC_F_UART_INT_EN_RX_FERR" },
      { ctrl: "RX_PARTY_ERROR_IE", value: "MXC_F_UART_INT_EN_RX_PAR" },
      { ctrl: "CTS_IE",            value: "MXC_F_UART_INT_EN_CTS_EV" },
      { ctrl: "RX_OVERRUN_IE",     value: "MXC_F_UART_INT_EN_RX_OV" },
      { ctrl: "RX_THD_IE",         value: "MXC_F_UART_INT_EN_RX_THD" },
      { ctrl: "TX_ONE_BYTE_IE",    value: "MXC_F_UART_INT_EN_TX_OB" },
      { ctrl: "TX_HALF_EMPTY_IE",  value: "MXC_F_UART_INT_EN_TX_HE" }
    ];
  }
  let arg = "";
  for (ie of ie_table) {
    if (getPeriConfigValue(it.instance, ie.ctrl, "FALSE") === "TRUE") {
      if (arg !== "")
        arg += " | ";
      arg += ie.value;
    }
  }
  return arg;
}
%>
<% if (isUnassignedPeripheralClockSetTo(it.instance, it.enable, "TRUE")) { %>
  /* The <%= it.instance %> peripheral is enabled on the clock canvas but is
   * not assigned to any core. In order to generate configuration code, please
   * assign the peripheral to a core.
   */

<% } else if (getAssignedPeripheral(it.instance)) { %>
  { /* Configure <%= it.instance %>.
<%   if (getPeripheralDescription(it.instance)) { %>
     * This peripheral is used for <%= getPeripheralDescription(it.instance) %>.
<%   } %>
<%   if (it.enable && !isPeripheralClockSetTo(it.instance, it.enable, "TRUE")) { %>
     * Note: This peripheral was not enabled on the clock configuration canvas.
     * Nonetheless, as a result of the following configuration, the peripheral will be
     * clocked on.
<%   } %>
     */

    /* Initialize the peripheral. */
    result = MXC_UART_Init(MXC_<%= it.msdk_instance ?? it.instance %>,
<%   if (it.datamodel.Name === "MAX32650") { %>
                           <%= getUartBaud() %>U);
<%   } else if (it.datamodel.Name === "MAX32660" || it.datamodel.Name === "MAX32666") { %>
                           <%= getUartBaud() %>U,
                           MAP_A /*dummy*/);
<%   } else if (it.datamodel.Name === "MAX32662") { %>
                           <%= getUartBaud() %>U,
                           <%= getUartClock() %>,
                           MAP_A /*dummy*/);
<%   } else { %>
                           <%= getUartBaud() %>U,
                           <%= getUartClock() %>);
<%   } %>
    if (result != E_NO_ERROR) {
      return result;
    }

<%   if (it.datamodel.Name === "MAX32650" || it.datamodel.Name === "MAX32666") { %>
    result = MXC_UART_SetClockSource(MXC_<%= it.msdk_instance ?? it.instance %>, <%= getUartClock() === "MXC_UART_APB_CLK" ? 1 : 0 %>);
    if (result < 0) {
      return result;
    }

<%   } %>
    /* Set Data Size. */
    result = MXC_UART_SetDataSize(MXC_<%= it.msdk_instance ?? it.instance %>, <%= getUARTDataSize() %>);
    if (result != E_NO_ERROR) {
      return result;
    }

    /* Set Stop Bits. */
    result = MXC_UART_SetStopBits(MXC_<%= it.msdk_instance ?? it.instance %>, <%= getUARTStopBits() %>);
    if (result != E_NO_ERROR) {
      return result;
    }

<%   if (getPeriConfigValue(it.instance, "HW_FLOW_CTRL", null) !== null) { %>
    /* Set Flow Control. */
<%   if (it.datamodel.Name === "MAX32666") { %>
    result = MXC_UART_SetFlowCtrl(MXC_<%= it.msdk_instance ?? it.instance %>, <%= getUARTFlowCtrl() %>, MAP_A /*dummy*/);
<%   } else { %>
    result = MXC_UART_SetFlowCtrl(MXC_<%= it.msdk_instance ?? it.instance %>, <%= getUARTFlowCtrl() %>);
<%   } %>
    if (result != E_NO_ERROR) {
      return result;
    }

<%   } %>
    /* Set Parity. */
    result = MXC_UART_SetParity(MXC_<%= it.msdk_instance ?? it.instance %>, <%= getUARTParity() %>);
    if (result != E_NO_ERROR) {
      return result;
    }

<%   if (it.datamodel.Name === "MAX32650" || it.datamodel.Name === "MAX32660" || it.datamodel.Name === "MAX32666") { %>
    /* Set Null Modem. */
    result = MXC_UART_SetNullModem(MXC_<%= it.msdk_instance ?? it.instance %>, <%= getUARTNullModem() %>);
    if (result != E_NO_ERROR) {
      return result;
    }

<%   } %>
<%   if (getUartIntMask() !== "") { %>

    /* Enable interrupts. */
<%     if (it.datamodel.Name === "MAX32650" || it.datamodel.Name === "MAX32666") { %>
    MXC_UART_EnableInt(MXC_<%= it.msdk_instance ?? it.instance %>, <%= getUartIntMask() %>);
<%     } else { %>
    result = MXC_UART_EnableInt(MXC_<%= it.msdk_instance ?? it.instance %>, <%= getUartIntMask() %>);
    if (result != E_NO_ERROR) {
      return result;
    }
<%     } %>
<%   } %>
  }

<% } %>
