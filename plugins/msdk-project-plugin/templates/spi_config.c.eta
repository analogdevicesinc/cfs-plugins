<%
/**
 * Copyright (c) 2025 Analog Devices, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// Return the SPI Type enumeration value for this instance.
function getSpiType() {
  let target = getPeriConfigValue(it.instance, "DIRECTION", "TARGET");
  return target === "TARGET" ? "MXC_SPI_TYPE_TARGET" : "MXC_SPI_TYPE_CONTROLLER";
}

// Return the SPI Mode enumeration value for this instance.
function getSpiMode() {
  let mode = "STANDARD";
  switch (getPeriConfigValue(it.instance, "MODE", "STANDARD")) {
    case "THREE_WIRE":
      mode = "3WIRE";
      break;
    case "DUAL":
      mode = "DUAL";
      break;
    case "QUAD":
      mode = "QUAD";
      break;
  }
  return mode;
}

// Return the number of targets used for this instance.
// Not used in v2 of the API.
function getSpiNumTargets() {
  return getPeriConfigValue(it.instance, "NUM_TARGETS", "0");
}

// Return a mask of the polarity of the chip select pins.
function getSpiPolarityMask() {
  let mask = 0;
  if (getPeriConfigValue(it.instance, "CS0_POLARITY", "ACTIVE_LOW") === "ACTIVE_HIGH") {
    mask |= 1;
  }
  if (getPeriConfigValue(it.instance, "CS1_POLARITY", "ACTIVE_LOW") === "ACTIVE_HIGH") {
    mask |= 2;
  }
  if (getPeriConfigValue(it.instance, "CS2_POLARITY", "ACTIVE_LOW") === "ACTIVE_HIGH") {
    mask |= 4;
  }
  if (getPeriConfigValue(it.instance, "CS3_POLARITY", "ACTIVE_LOW") === "ACTIVE_HIGH") {
    mask |= 8;
  }
  return mask;
}

// Return the SPI frequency value string.
function getSpiFreq() {
  const freq = getPeriConfigValue(it.instance, "FREQ", null);
  if (freq === null) {
    return `(${it.clock} / 4U)`;
  }
  return `${freq}U`;
}

// Return the SPI clock mode.
function getSpiClkMode() {
  return getPeriConfigValue(it.instance, "PHASE_POL_MODE", "0");
}

// Return the DMA TX setting.
function getSpiDmaTx() {
  return getPeriConfigValue(it.instance, "TRANSMIT_DMA_ENABLE", "FALSE") === "TRUE";
}

// Return the DMA RX setting.
function getSpiDmaRx() {
  return getPeriConfigValue(it.instance, "RECEIVE_DMA_ENABLE", "FALSE") === "TRUE";
}

// Return the DMA structure.
function getSpiDma() {
  return "MXC_DMA";
}

// Return the SPI frame size.
function getSpiFrameSize() {
  return getPeriConfigValue(it.instance, "WORD_SIZE", "16");
}

// Return the version of the API to use.
function getSpiAPIVersion() {
  return 1;
}

// Return the interrupt mask for any enabled interrupts.
function getSpiIntMask() {
  let ie_table;
  if (it.datamodel.Name === "MAX32650") {
    ie_table = [
      { ctrl: "TX_THD_IE",    value: "MXC_F_SPI_INT_EN_TX_LEVEL" },
      { ctrl: "TX_EM_IE",     value: "MXC_F_SPI_INT_EN_TX_EMPTY" },
      { ctrl: "RX_THD_IE",    value: "MXC_F_SPI_INT_EN_RX_LEVEL" },
      { ctrl: "RX_FULL_IE",   value: "MXC_F_SPI_INT_EN_RX_FULL" },
      { ctrl: "FAULT_IE",     value: "MXC_F_SPI_INT_EN_FAULT" },
      { ctrl: "ABORT_IE",     value: "MXC_F_SPI_INT_EN_ABORT" },
      { ctrl: "TX_OV_IE",     value: "MXC_F_SPI_INT_EN_TX_OVR" },
      { ctrl: "TX_UN_IE",     value: "MXC_F_SPI_INT_EN_TX_UND" },
      { ctrl: "RX_OV_IE",     value: "MXC_F_SPI_INT_EN_RX_OVR" },
      { ctrl: "RX_UN_IE",     value: "MXC_F_SPI_INT_EN_RX_UND" }
    ];
  } else {
    ie_table = [
      { ctrl: "TX_THD_IE",    value: "MXC_F_SPI_INTEN_TX_THD" },
      { ctrl: "TX_EM_IE",     value: "MXC_F_SPI_INTEN_TX_EM" },
      { ctrl: "RX_THD_IE",    value: "MXC_F_SPI_INTEN_RX_THD" },
      { ctrl: "RX_FULL_IE",   value: "MXC_F_SPI_INTEN_RX_FULL" },
      { ctrl: "FAULT_IE",     value: "MXC_F_SPI_INTEN_FAULT" },
      { ctrl: "ABORT_IE",     value: "MXC_F_SPI_INTEN_ABORT" },
      { ctrl: "TX_OV_IE",     value: "MXC_F_SPI_INTEN_TX_OV" },
      { ctrl: "TX_UN_IE",     value: "MXC_F_SPI_INTEN_TX_UN" },
      { ctrl: "RX_OV_IE",     value: "MXC_F_SPI_INTEN_RX_OV" },
      { ctrl: "RX_UN_IE",     value: "MXC_F_SPI_INTEN_RX_UN" }
    ];
  }
  if (it.datamodel.Name === "MAX32657" || it.datamodel.Name === "MAX32658") {
    ie_table.push.apply(ie_table, [
      { ctrl: "CSA_IE",       value: "MXC_F_SPI_INTEN_TSA" },
      { ctrl: "CSD_IE",       value: "MXC_F_SPI_INTEN_TSD" },
      { ctrl: "CTRL_DONE_IE", value: "MXC_F_SPI_INTEN_CONT_DONE" }
    ]);
  }  else if (it.datamodel.Name === "MAX32650") {
    ie_table.push.apply(ie_table, [
      { ctrl: "CSA_IE",       value: "MXC_F_SPI_INT_EN_SSA" },
      { ctrl: "CSD_IE",       value: "MXC_F_SPI_INT_EN_SSD" },
      { ctrl: "CTRL_DONE_IE", value: "MXC_F_SPI_INT_EN_M_DONE" }
    ]);
  } else {
    ie_table.push.apply(ie_table, [
      { ctrl: "CSA_IE",       value: "MXC_F_SPI_INTEN_SSA" },
      { ctrl: "CSD_IE",       value: "MXC_F_SPI_INTEN_SSD" },
      { ctrl: "CTRL_DONE_IE", value: "MXC_F_SPI_INTEN_MST_DONE" }
    ]);
  }
  let arg = "";
  for (ie of ie_table) {
    if (getPeriConfigValue(it.instance, ie.ctrl, "FALSE") === "TRUE") {
      if (arg !== "")
        arg += " | ";
      arg += ie.value;
    }
  }
  return arg;
}
%>
<% if (isUnassignedPeripheralClockSetTo(it.instance, it.enable, "TRUE")) { %>
  /* The <%= it.instance %> peripheral is enabled on the clock canvas but is
   * not assigned to any core. In order to generate configuration code, please
   * assign the peripheral to a core.
   */

<% } else if (getAssignedPeripheral(it.instance)) { %>
  { /* Configure <%= it.instance %>.
<%   if (getPeripheralDescription(it.instance)) { %>
     * This peripheral is used for <%= getPeripheralDescription(it.instance) %>.
<%   } %>
<%   if (it.enable && !isPeripheralClockSetTo(it.instance, it.enable, "TRUE")) { %>
     * Note: This peripheral was not enabled on the clock configuration canvas.
     * Nonetheless, as a result of the following configuration, the peripheral will be
     * clocked on.
<%   } %>
     */
<%  if (it.datamodel.Name !== "MAX32650" && it.datamodel.Name !== "MAX32670") { %>
    mxc_spi_pins_t <%= it.instance.toLowerCase() %>_pins_dummy = { 0 };
<%  } %>
<%   if (getSpiAPIVersion() == 2) { %>
    mxc_spi_cfg_t <%= it.instance.toLowerCase() %>_config = {
      .spi = MXC_<%= it.instance %>,
      .clk_mode = MXC_SPI_CLKMODE_<%= getSpiClkMode() %>,
      .frame_size = <%= getSpiFrameSize() %>U, // bits per character
      .use_dma_tx = <%= getSpiDmaTx() %>,
      .use_dma_rx = <%= getSpiDmaRx() %>,
<%     if (getSpiDmaTx() || getSpiDmaRx()) { %>
      .dma = <%= getSpiDma() %> // DMA regs
<%     } else { %>
      .dma = NULL // DMA regs
<%     } %>
    };

    /* Initialize the peripheral. */
    result = MXC_SPI_Init(MXC_<%= it.msdk_instance ?? it.instance %>,
                          <%= getSpiType() %>,
                          MXC_SPI_INTERFACE_<%= getSpiMode() %>,
                          <%= getSpiNumTargets() %>, /* unused */
                          <%= getSpiPolarityMask() %>U, /* polarity mask */
                          <%= getSpiFreq() %>, /* frequency */
                          <%= it.instance.toLowerCase() %>_pins_dummy);
    if (result != E_NO_ERROR) {
      return result;
    }

    /* Configure bits per character, clock phase and polarity mode, and DMA. */
    result = MXC_SPI_Config(&<%= it.instance.toLowerCase() %>_config);
<%   } else { %>
    /* Initialize the peripheral. */
    result = MXC_SPI_Init(MXC_<%= it.msdk_instance ?? it.instance %>,
                          <%= getSpiType() === "MXC_SPI_TYPE_CONTROLLER" ? 1 : 0 %>, /* 0 for target, 1 for controller */
                          <%= getSpiMode() === "QUAD" ? 1 : 0 %>, /* 1 for quad mode, 0 otherwise */
                          <%= getSpiNumTargets() %>, /* number of targets */
                          <%= getSpiPolarityMask() %>U, /* polarity mask */
<%  if (it.datamodel.Name !== "MAX32650" && it.datamodel.Name !== "MAX32670") { %>
                          <%= getSpiFreq() %>, /* frequency */
                          <%= it.instance.toLowerCase() %>_pins_dummy);
<%  } else { %>
                          <%= getSpiFreq() %>); /* frequency */
<%  } %>
    if (result != E_NO_ERROR) {
      return result;
    }

    /* Set the width. */
    result = MXC_SPI_SetWidth(MXC_<%= it.msdk_instance ?? it.instance %>, SPI_WIDTH_<%= getSpiMode() %>);
    if (result != E_NO_ERROR) {
      return result;
    }

    /* Set the bits per character. */
    result = MXC_SPI_SetDataSize(MXC_<%= it.msdk_instance ?? it.instance %>, <%= getSpiFrameSize() %>);
    if (result != E_NO_ERROR) {
      return result;
    }

    /* Set the clock mode. */
    result = MXC_SPI_SetMode(MXC_<%= it.msdk_instance ?? it.instance %>, SPI_MODE_<%= getSpiClkMode() %>);
<%   } %>
    if (result != E_NO_ERROR) {
      return result;
    }
<%   if (getSpiIntMask() !== "") { %>

    /* Enable interrupts. */
    MXC_SPI_EnableInt(MXC_<%= it.msdk_instance ?? it.instance %>, <%= getSpiIntMask() %>);
<%   } %>
  }

<% } %>
