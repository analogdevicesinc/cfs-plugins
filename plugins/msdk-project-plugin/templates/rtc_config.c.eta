<%
/**
 * Copyright (c) 2025 Analog Devices, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// Return the interrupt mask for any enabled interrupts.
function getRTCIntMask() {
  const ie_table = [
    { ctrl: "TOD_ALARM_IE",  value: "MXC_RTC_INT_EN_LONG" },
    { ctrl: "SSEC_ALARM_IE", value: "MXC_RTC_INT_EN_SHORT" },
    { ctrl: "RDY_IE",        value: "MXC_RTC_INT_EN_READY" }
  ];
  let arg = "";
  for (ie of ie_table) {
    if (getPeriConfigValue(it.instance, ie.ctrl, "FALSE") === "TRUE") {
      if (arg !== "")
        arg += " | ";
      arg += ie.value;
    }
  }
  return arg;
}

// Get the SQWOUT frequency, if any.
function getSQWOUTFreq() {
  if (clockNodeExists(it.output_clocknode)) {
    if (!it.enable || isClockSetTo(it.enable_clocknode, it.enable, "TRUE")) {
      if (getClockSetting(it.output_clocknode, it.output_ctrl) === "RTC_DIV_4096" || (it.enable && !isClockSet(it.output_clocknode, it.output_ctrl))) {
        return "1HZ";
      } else if (getClockSetting(it.output_clocknode, it.output_ctrl) === "RTC_DIV_8") {
        return "512HZ";
      } else if (getClockSetting(it.output_clocknode, it.output_ctrl) === "CLK_4KHZ") {
        return "4KHZ";
      } else if (getClockSetting(it.output_clocknode, it.output_ctrl) === "ERTCO") {
        return "32KHZ";
      } else if (isClockSet(it.output_clocknode, it.output_ctrl) && !isClockSetTo(it.output_clocknode, it.output_ctrl, "DIS")) {
        return getClockSetting(it.output_clocknode, it.output_ctrl, "1HZ");
      }
    }
  }
  return undefined;
}

// Get the frequency of the sub-second alarm.
function getRTCSubSecondFreq() {
  return 4096;
}
%>
<% if (!getAssignedProjectForPeripheral(it.instance) && clockNodeExists(it.output_clocknode) && ((isClockSet(it.output_clocknode, it.output_ctrl) && !isClockSetTo(it.output_clocknode, it.output_ctrl, "DIS")) || (it.enable && isClockSetTo(it.enable_clocknode, it.enable, "TRUE")))) { %>
  /* The <%= it.output_clocknode %> clock node is enabled on the clock canvas but the RTC
   * peripheral is not assigned to any core. In order to generate configuration code,
   * please assign the peripheral to a core.
   */

<% } else if (getAssignedPeripheral(it.instance)) { %>
  { /* Configure <%= it.instance %>.
<%   if (getPeripheralDescription(it.instance)) { %>
     * This peripheral is used for <%= getPeripheralDescription(it.instance) %>.
<%   } %>
<%   if (it.enable && !isClockSetTo(it.enable_clocknode, it.enable, "TRUE")) { %>
     * Note: This peripheral was not enabled on the clock configuration canvas.
     * Nonetheless, as a result of the following configuration, the peripheral will be
     * clocked on.
<%   } %>
     */

    /* Initialize the peripheral. */
    result = MXC_RTC_Init(<%= getPeriConfigValue(it.instance, "SEC", "0") %>U,
<%   if (getPeriConfigValue(it.instance, "SSEC_UNITS", "TICKS") === "MS") { %>
                          (<%= getPeriConfigValue(it.instance, "SSEC_MS", "0") %>U * <%= getRTCSubSecondFreq() %>U) / 1000U);
<%   } else { %>
                          <%= getPeriConfigValue(it.instance, "SSEC_TICKS", getPeriConfigValue(it.instance, "SSEC", "0")) %>U);
<%   } %>
    if (result != E_NO_ERROR) {
      return result;
    }

<%   if (it.datamodel.Name !== "MAX32650") { %>
    result = MXC_RTC_Trim(<%= getPeriConfigValue(it.instance, "TRIM", "0") %>);
    if (result != E_NO_ERROR) {
      return result;
    }

<%   } %>
    /* Set the time-of-day alarm value. */
    result = MXC_RTC_SetTimeofdayAlarm(<%= getPeriConfigValue(it.instance, "TOD_ALARM", "0") %>U);
    if (result != E_NO_ERROR) {
      return result;
    }

    /* Set the sub-second alarm value. */
<%   if (getPeriConfigValue(it.instance, "SSEC_UNITS", "TICKS") === "MS") { %>
<%     if (Number(getPeriConfigValue(it.instance, "SSEC_ALARM_MS", "0")) > (0xFFFFFFFF / getRTCSubSecondFreq())) { %>
    result = MXC_RTC_SetSubsecondAlarm(0U - (uint32_t)((<%= getPeriConfigValue(it.instance, "SSEC_ALARM_MS", "0") %>ULL * <%= getRTCSubSecondFreq() %>U) / 1000U));
<%     } else { %>
    result = MXC_RTC_SetSubsecondAlarm(0U - ((<%= getPeriConfigValue(it.instance, "SSEC_ALARM_MS", "0") %>U * <%= getRTCSubSecondFreq() %>U) / 1000U));
<%     } %>
<%   } else { %>
    result = MXC_RTC_SetSubsecondAlarm(0U - <%= getPeriConfigValue(it.instance, "SSEC_ALARM_TICKS", getPeriConfigValue(it.instance, "SSEC_ALARM", "0")) %>U);
<%   } %>
    if (result != E_NO_ERROR) {
      return result;
    }

<%   if (getRTCIntMask() !== "") { %>
    /* Enable interrupts. */
    result = MXC_RTC_EnableInt(<%= getRTCIntMask() %>);
    if (result != E_NO_ERROR) {
      return result;
    }

<%   } %>
<%   if (getSQWOUTFreq()) { %>
    /* Start the Square Wave Output. */
    result = MXC_RTC_SquareWaveStart(MXC_RTC_F_<%= getSQWOUTFreq() %>);
    if (result != E_NO_ERROR) {
      return result;
    }
<%   } %>
  }

<% } %>
