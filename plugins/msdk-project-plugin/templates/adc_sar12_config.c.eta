<%
/**
 * Copyright (c) 2025 Analog Devices, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// Return the ADC clock source enum.
function getADCClock() {
  const clock = getPeripheralClockSetting(it.instance, it.mux, it.clock_default);
  let clock_enum = "SYS_OSC";
  switch (clock) {
    case "ADC_CLK_EXT":
      clock_enum = "EXT";
      break;
    case "ERFO":
    case "IBRO":
      clock_enum = clock;
      break;
    case "SYS_CLK":
      if (it.datamodel.Name === "MAX78002") {
      clock_enum = "HCLK";
      } else {
      clock_enum = "SYS_OSC";
      }
      break;
  }
  return clock_enum;
}

// Get the divider for the ADC
function getADCDiv() {
  return getPeripheralClockSetting(it.instance, it.div, "16");
}

// Get the trigger select.
function getADCTrigSel() {
  let sel = getPeriConfigValue(it.instance, "TRIG_SEL", "TMR0");
  switch (sel) {
    case "AIN_TRIG_A":
      sel = "P0_10";
      break;
    case "AIN_TRIG_B":
      sel = "P1_0";
      break;
    case "ADC_HW_TRIG_A":
      sel = "P1_12";
      break;
    case "ADC_HW_TRIG_B":
      sel = "P1_13";
      break;
    case "ADC_HW_TRIG_C":
      sel = it.datamodel.Name === "MAX78002" ? "P1_14" : "P2_15";
      break;
    case "THERM_RDY":
      sel = "TEMP_SENS";
      break;
  }
  return sel;
}

// Return the channel ID for the given slot.
function getADCChannel(slot) {
  const channel = getPeriConfigValue(it.instance, "SLOT" + slot + "_ID", "AIN0");
  switch (channel) {
    case "AIN0":
      return "MXC_ADC_CH_0";
    case "AIN1":
      return "MXC_ADC_CH_1";
    case "AIN2":
      return "MXC_ADC_CH_2";
    case "AIN3":
      return "MXC_ADC_CH_3";
    case "AIN4":
      return "MXC_ADC_CH_4";
    case "AIN5":
      return "MXC_ADC_CH_5";
    case "AIN6":
      return "MXC_ADC_CH_6";
    case "AIN7":
      return "MXC_ADC_CH_7";
    case "AIN8":
      return "MXC_ADC_CH_8";
    case "AIN9":
      return "MXC_ADC_CH_9";
    case "AIN10":
      return "MXC_ADC_CH_10";
    case "AIN11":
      return "MXC_ADC_CH_11";
    case "VDDA_2":
      return "MXC_ADC_CH_VDDA_DIV2";
    case "TEMP":
      return it.datamodel.Name === "MAX78002" ? "MXC_ADC_CH_TEMP_SENSOR" : "MXC_ADC_CH_TEMP_SENS";
    case "VCORE_A":
      return "MXC_ADC_CH_VCOREA";
    case "VDD3A_4":
      // There is no MSDK enum for this.
      return "18 /* VDD3A/4 */";
    case "VDDB_4":
      // There is no MSDK enum for this.
      return "19 /* VDDB/4 */";
    case "VSSA":
      // There is no MSDK enum for this.
      return "20 /* VSSA */";
  }
  return "MXC_ADC_CH_" + channel;
}

// Return the interrupt mask for any enabled interrupts.
function getADCIntMask() {
  const ie_table = [
    { ctrl: "READY_IE",       value: "MXC_F_ADC_INTEN_READY" },
    { ctrl: "ABORT_IE",       value: "MXC_F_ADC_INTEN_ABORT" },
    { ctrl: "START_DET_IE",   value: "MXC_F_ADC_INTEN_START_DET" },
    { ctrl: "SEQ_STARTED_IE", value: "MXC_F_ADC_INTEN_SEQ_STARTED" },
    { ctrl: "SEQ_DONE_IE",    value: "MXC_F_ADC_INTEN_SEQ_DONE" },
    { ctrl: "CONV_DONE_IE",   value: "MXC_F_ADC_INTEN_CONV_DONE" },
    { ctrl: "CLIPPED_IE",     value: "MXC_F_ADC_INTEN_CLIPPED" },
    { ctrl: "FIFO_LVL_IE",    value: "MXC_F_ADC_INTEN_FIFO_LVL" },
    { ctrl: "FIFO_UFL_IE",    value: "MXC_F_ADC_INTEN_FIFO_UFL" },
    { ctrl: "FIFO_OFL_IE",    value: "MXC_F_ADC_INTEN_FIFO_OFL" }
  ];
  let arg = "";
  for (ie of ie_table) {
    if (getPeriConfigValue(it.instance, ie.ctrl, "FALSE") === "TRUE") {
      if (arg !== "")
        arg += " | ";
      arg += ie.value;
    }
  }
  return arg;
}

// Function to generate DMA-related comments
function addDMAComments() {
  const dmaEnabled = getPeriConfigValue(it.instance, "DMA_EN", "FALSE") === "TRUE";
  if (dmaEnabled) {
    return `
    /* Note: DMA is not enabled for ${it.instance}.
     * To use DMA, please call MXC_ADC_StartConversionDMA() in your application code.
     * Refer to the documentation for more details.
     */
    `;
  }
  return "";
}
%>
<% if (isUnassignedPeripheralClockSetTo(it.instance, it.enable, "TRUE")) { %>
  /* The <%= it.instance %> peripheral is enabled on the clock canvas but is
   * not assigned to any core. In order to generate configuration code, please
   * assign the peripheral to a core.
   */

<% } else if (getAssignedPeripheral(it.instance)) { %>
  { /* Configure <%= it.instance %>.
<%   if (getPeripheralDescription(it.instance)) { %>
     * This peripheral is used for <%= getPeripheralDescription(it.instance) %>.
<%   } %>
<%   if (it.enable && !isPeripheralClockSetTo(it.instance, it.enable, "TRUE")) { %>
     * Note: This peripheral was not enabled on the clock configuration canvas.
     * Nonetheless, as a result of the following configuration, the peripheral will be
     * clocked on.
<%   } %>
     */
<%   if (addDMAComments() !== "") { %>
    <%= addDMAComments() %>
<%   } %>

    /* Initialize the peripheral. */
    mxc_adc_req_t <%= it.instance.toLowerCase() %>_config = {
      .clock = MXC_ADC_CLK_<%= getADCClock() %>,
      .clkdiv = MXC_ADC_CLKDIV_<%= getADCDiv() %>,
      .cal = MXC_ADC_<%= getPeriConfigValue(it.instance, "SKIP_CAL", "FALSE") === "TRUE" ? "SKIP_CAL" : "EN_CAL" %>,
      .ref = MXC_ADC_REF_<%= getPeriConfigValue(it.instance, "REF_TRIM", "INT_1V25") %>,
      .trackCount = <%= getPeriConfigValue(it.instance, "TRACK_CNT", "0") %>,
      .idleCount = <%= getPeriConfigValue(it.instance, "IDLE_CNT", "0") %> 
    };
    result = MXC_ADC_Init(&<%= it.instance.toLowerCase() %>_config);
    if (result != E_NO_ERROR) {
      return result;
    }

    mxc_adc_conversion_req_t <%= it.instance.toLowerCase() %>_conv_config = {
      .mode = MXC_ADC_<%= getPeriConfigValue(it.instance, "CONV_MODE", "ATOMIC") %>_CONV,
      .trig = MXC_ADC_TRIG_<%= getPeriConfigValue(it.instance, "TRIG_MODE", "SOFTWARE") %>,
      .hwTrig = MXC_ADC_TRIG_SEL_<%= getADCTrigSel() %>,
      .fifo_format = MXC_ADC_<%= getPeriConfigValue(it.instance, "DATA_FORMAT", "DATA_STATUS") %>, // Dummy
      .fifo_threshold = <%= getPeriConfigValue(it.instance, "THRESH", "0") %>,
      .avg_number = MXC_ADC_AVG_<%= getPeriConfigValue(it.instance, "AVG", "1") %>,
      .lpmode_divder = MXC_ADC_DIV_<%= getPeriConfigValue(it.instance, "LPMODE_DIV", "2_5K_50K_ENABLE") %>,
      .num_slots = <%= getPeriConfigValue(it.instance, "NUM_SLOTS", "1") %>,
      .dma_channel = <%= getPeriConfigValue(it.instance, "DMA_CHAN", "0") %> 
    };
    result = MXC_ADC_Configuration(&<%= it.instance.toLowerCase() %>_conv_config);
    if (result != E_NO_ERROR) {
      return result;
    }

    mxc_adc_slot_req_t <%= it.instance.toLowerCase() %>_slots_config[<%= getPeriConfigValue(it.instance, "NUM_SLOTS", "1") %>] = {
<%   for (let slot = 0; slot < parseInt(getPeriConfigValue(it.instance, "NUM_SLOTS", "1")); slot += 1) { %>
       { <%= getADCChannel(slot) %> }<% if (slot < parseInt(getPeriConfigValue(it.instance, "NUM_SLOTS", "1") - 1)) { %>,<% } %> 
<%   } %>
    };
    result = MXC_ADC_SlotConfiguration(&<%= it.instance.toLowerCase() %>_slots_config[0], <%= getPeriConfigValue(it.instance, "NUM_SLOTS", "1") %>U);
    if (result != E_NO_ERROR) {
      return result;
    }

<%   if (getPeriConfigValue(it.instance, "CONV_MODE", "ATOMIC") === "CONTINUOUS") { %>
    MXC_ADC_SetConversionDelay(<%= getPeriConfigValue(it.instance, "SKIP_CNT", "0") %>);

<%   } %>
<%   if (getADCIntMask() !== "") { %>
    /* Enable interrupts. */
    MXC_ADC_EnableInt(<%= getADCIntMask() %>);
<%   } %>
  }

<% } %>
