<%
/**
 * Copyright (c) 2025 Analog Devices, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

// Return the I2C mode value for this instance.
function getI2CType() {
  return getPeriConfigValue(it.instance, "MODE", "TARGET") === "TARGET" ? "0" : "1";
}

// Return the I2C clock stretching value for this instance.
function getI2CClockStretching() {
  return getPeriConfigValue(it.instance, "CLKSTR", "FALSE") === "TRUE" ? "1" : "0";
}

// Return the I2C target address for this instance.
function getI2CTargAddr() {
  const target0Addr = getPeriConfigValue(it.instance, "TARGET0_ADDR", null);
  if (target0Addr !== null) {
    return target0Addr;
  }
  return getPeriConfigValue(it.instance, "ADDR", "0");
}

// Return the I2C timeout period for this instance.
function getI2CTimeout() {
  return getPeriConfigValue(it.instance, "SCL_TIMEOUT", "0");
}

// Return the I2C frequency value string.
function getI2CFreq() {
  return getPeriConfigValue(it.instance, "FREQ", "100000");
}

// Return the DMA TX setting.
function getI2CDmaTx() {
  return getPeriConfigValue(it.instance, "TRANSMIT_DMA_ENABLE", "FALSE") === "TRUE";
}

// Return the DMA RX setting.
function getI2CDmaRx() {
  return getPeriConfigValue(it.instance, "RECEIVE_DMA_ENABLE", "FALSE") === "TRUE";
}

// Return the DMA structure.
function getI2CDma() {
  return "MXC_DMA";
}

// Return the interrupt mask for any enabled interrupts.
function getI2CIntMask0() {
  let ie_table;
  if (it.datamodel.Name === "MAX32650") {
    ie_table = [
      { ctrl: "DONE_IE",          value: "MXC_F_I2C_INT_EN0_DONEIE" },
      { ctrl: "IRXM_IE",          value: "MXC_F_I2C_INT_EN0_IRXMIE" },
      { ctrl: "GC_ADDR_MATCH_IE", value: "MXC_F_I2C_INT_EN0_GCIE" },
      { ctrl: "ADDR_MATCH_IE",    value: "MXC_F_I2C_INT_EN0_AMIE" },
      { ctrl: "RX_THD_IE",        value: "MXC_F_I2C_INT_EN0_RXTHIE" },
      { ctrl: "TX_THD_IE",        value: "MXC_F_I2C_INT_EN0_TXTHIE" },
      { ctrl: "STOP_IE",          value: "MXC_F_I2C_INT_EN0_STOPIE" },
      { ctrl: "ADDR_ACK_IE",      value: "MXC_F_I2C_INT_EN0_ADRACKIE" },
      { ctrl: "ARB_ERR_IE",       value: "MXC_F_I2C_INT_EN0_ARBERIE" },
      { ctrl: "TO_ERR_IE",        value: "MXC_F_I2C_INT_EN0_TOERIE" },
      { ctrl: "ADDR_NACK_ERR_IE", value: "MXC_F_I2C_INT_EN0_ADRERIE" },
      { ctrl: "DATA_ERR_IE",      value: "MXC_F_I2C_INT_EN0_DATAERIE" },
      { ctrl: "DNR_ERR_IE",       value: "MXC_F_I2C_INT_EN0_DNRERIE" },
      { ctrl: "START_ERR_IE",     value: "MXC_F_I2C_INT_EN0_STRTERIE" },
      { ctrl: "STOP_ERR_IE",      value: "MXC_F_I2C_INT_EN0_STOPERIE" },
      { ctrl: "TX_LOCKOUT_IE",    value: "MXC_F_I2C_INT_EN0_TXLOIE" }
    ];
  } else {
    ie_table = [
      { ctrl: "DONE_IE",          value: "MXC_F_I2C_INTEN0_DONE" },
      { ctrl: "IRXM_IE",          value: "MXC_F_I2C_INTEN0_IRXM" },
      { ctrl: "GC_ADDR_MATCH_IE", value: "MXC_F_I2C_INTEN0_GC_ADDR_MATCH" },
      { ctrl: "ADDR_MATCH_IE",    value: "MXC_F_I2C_INTEN0_ADDR_MATCH" },
      { ctrl: "RX_THD_IE",        value: "MXC_F_I2C_INTEN0_RX_THD" },
      { ctrl: "TX_THD_IE",        value: "MXC_F_I2C_INTEN0_TX_THD" },
      { ctrl: "STOP_IE",          value: "MXC_F_I2C_INTEN0_STOP" },
      { ctrl: "ADDR_ACK_IE",      value: "MXC_F_I2C_INTEN0_ADDR_ACK" },
      { ctrl: "ARB_ERR_IE",       value: "MXC_F_I2C_INTEN0_ARB_ERR" },
      { ctrl: "TO_ERR_IE",        value: "MXC_F_I2C_INTEN0_TO_ERR" },
      { ctrl: "ADDR_NACK_ERR_IE", value: "MXC_F_I2C_INTEN0_ADDR_NACK_ERR" },
      { ctrl: "DATA_ERR_IE",      value: "MXC_F_I2C_INTEN0_DATA_ERR" },
      { ctrl: "DNR_ERR_IE",       value: "MXC_F_I2C_INTEN0_DNR_ERR" },
      { ctrl: "START_ERR_IE",     value: "MXC_F_I2C_INTEN0_START_ERR" },
      { ctrl: "STOP_ERR_IE",      value: "MXC_F_I2C_INTEN0_STOP_ERR" },
      { ctrl: "TX_LOCKOUT_IE",    value: "MXC_F_I2C_INTEN0_TX_LOCKOUT" },
      { ctrl: "MAMI0_IE",         value: "MXC_F_I2C_INTEN0_MAMI" },
      { ctrl: "MAMI1_IE",         value: "(MXC_F_I2C_INTEN0_MAMI+1)" },
      { ctrl: "MAMI2_IE",         value: "(MXC_F_I2C_INTEN0_MAMI+2)" },
      { ctrl: "MAMI3_IE",         value: "(MXC_F_I2C_INTEN0_MAMI+3)" },
      { ctrl: "RD_ADDR_MATCH_IE", value: "MXC_F_I2C_INTEN0_RD_ADDR_MATCH" },
      { ctrl: "WR_ADDR_MATCH_IE", value: "MXC_F_I2C_INTEN0_WR_ADDR_MATCH" }
    ];
  }
  let arg = "0U";
  for (ie of ie_table) {
    if (getPeriConfigValue(it.instance, ie.ctrl, "FALSE") === "TRUE") {
      if (arg !== "0U")
        arg += " | " + ie.value;
      else
        arg = ie.value;
    }
  }
  return arg;
}

// Return the interrupt mask for any enabled interrupts.
function getI2CIntMask1() {
  let ie_table;
  if (it.datamodel.Name === "MAX32650") {
    ie_table = [
      { ctrl: "RX_OV_IE",         value: "MXC_F_I2C_INT_EN1_RXOFIE" },
      { ctrl: "TX_UN_IE",         value: "MXC_F_I2C_INT_EN1_TXUFIE" }
    ];
  } else {
    ie_table = [
      { ctrl: "RX_OV_IE",         value: "MXC_F_I2C_INTEN1_RX_OV" },
      { ctrl: "TX_UN_IE",         value: "MXC_F_I2C_INTEN1_TX_UN" },
      { ctrl: "START_IE",         value: "MXC_F_I2C_INTEN1_START" }
    ];
  }
  let arg = "0U";
  for (ie of ie_table) {
    if (getPeriConfigValue(it.instance, ie.ctrl, "FALSE") === "TRUE") {
      if (arg !== "0U")
        arg += " | " + ie.value;
      else
        arg = ie.value;
    }
  }
  return arg;
}
%>
<% if (isUnassignedPeripheralClockSetTo(it.instance, it.enable, "TRUE")) { %>
  /* The <%= it.instance %> peripheral is enabled on the clock canvas but is
   * not assigned to any core. In order to generate configuration code, please
   * assign the peripheral to a core.
   */

<% } else if (getAssignedPeripheral(it.instance)) { %>
  { /* Configure <%= it.instance %>.
<%   if (getPeripheralDescription(it.instance)) { %>
     * This peripheral is used for <%= getPeripheralDescription(it.instance) %>.
<%   } %>
<%   if (it.enable && !isPeripheralClockSetTo(it.instance, it.enable, "TRUE")) { %>
     * Note: This peripheral was not enabled on the clock configuration canvas.
     * Nonetheless, as a result of the following configuration, the peripheral will be
     * clocked on.
<%   } %>
     */

    /* Initialize the peripheral. */
    result = MXC_I2C_Init(MXC_<%= it.instance %>,
                          <%= getI2CType() %>,
                          <%= getI2CTargAddr() %>U);
    if (result != E_NO_ERROR) {
      return result;
    }

    /* Set the frequency. */
    result = MXC_I2C_SetFrequency(MXC_<%= it.instance %>, <%= getI2CFreq() %>U);
    if (result < 0) {
      return result;
    }

    /* Enable or disable clock stretching. */
    result = MXC_I2C_SetClockStretching(MXC_<%= it.instance %>, <%= getI2CClockStretching() %>);
    if (result != E_NO_ERROR) {
      return result;
    }

    /* Set the timeout. */
    MXC_I2C_SetTimeout(MXC_<%= it.instance %>, <%= getI2CTimeout() %>U);

<%   if (getPeriConfigValue(it.instance, "PRELOAD_MODE", "NORMAL") === "PRELOAD") { %>
    /* Enable preload mode. */
    MXC_I2C_EnablePreload(MXC_<%= it.instance %>);

<%   } %>
<%   if (getPeriConfigValue(it.instance, "PRELOAD_MODE", "NORMAL") === "NORMAL") { %>
    /* Disable preload mode. */
    MXC_I2C_DisablePreload(MXC_<%= it.instance %>);

<%   } %>
<%   if (getPeriConfigValue(it.instance, "MODE", "TARGET") === "TARGET") { %>
<%     if (getPeriConfigValue(it.instance, "GC_ADDR_EN", "IGNORE") === "ACK") { %>
    /* Enable general call acknowledgement. */
    MXC_I2C_EnableGeneralCall(MXC_<%= it.instance %>);

<%     } else if (getPeriConfigValue(it.instance, "GC_ADDR_EN", "IGNORE") === "IGNORE") { %>
    /* Disable general call acknowledgement. */
    MXC_I2C_DisableGeneralCall(MXC_<%= it.instance %>);

<%     } %>
<%   } %>
<%   if (getI2CDmaTx() || getI2CDmaRx()) { %>
    /* Set up DMA. */
    result = MXC_I2C_DMA_Init(MXC_<%= it.instance %>,
                              <%= getI2CDma() %>,
                              <%= getI2CDmaTx() %> /*use TX DMA*/,
                              <%= getI2CDmaRx() %> /*use RX DMA*/);
    if (result != E_NO_ERROR) {
      return result;
    }

<%   } %>
<%   if (getI2CIntMask0() !== "0U" || getI2CIntMask1() !== "0U") { %>

    /* Enable interrupts. */
    MXC_I2C_EnableInt(MXC_<%= it.msdk_instance ?? it.instance %>,
                      <%= getI2CIntMask0() %>,
                      <%= getI2CIntMask1() %>);
<%   } %>
  }

<% } %>
