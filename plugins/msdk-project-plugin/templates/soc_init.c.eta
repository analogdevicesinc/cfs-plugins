<%
/**
 * Copyright (c) 2024-2025 Analog Devices, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

var pull_map = {
  "STRONG_PU" : "PULL_UP",
  "PU"        : "PULL_UP",
  "WEAK_PU"   : "WEAK_PULL_UP",
  "STRONG_PD" : "PULL_DOWN",
  "PD"        : "PULL_DOWN",
  "WEAK_PD"   : "WEAK_PULL_DOWN",
  "DIS"       : "NONE"
}

function getGpioPorts() {
  const ports = new Set();
  for (const pin of it.cfsconfig.Pins) {
    const p = getPin(pin);
    ports.add(p.GPIOPort);
  }
  return Array.from(ports).sort()
}

function getVssel(pin, signal) {
  // Hardware constraint: GPIO ports controlled by MCR registers on devices 
  // with VDDIOH pin can only use VDDIOH as their I/O voltage supply
  const gpioName = getPin(pin).GPIOName.toString();
  const hasVddioh = getPackage()?.Pins.some((p) => p.Label === "VDDIOH");
  const hasMcrCtrl = it.datamodel.Registers.some((r) => r.Name === `MCR_${gpioName}_CTRL`);

  if (hasVddioh && hasMcrCtrl) {
    return "VDDIOH";
  }

  return signal?.Config?.PWR ?? "VDDIO";
}

function sanitize_identifier(iden) {
  return iden.replace(".", "_");
}

function getHeaders() {
  const hdrs = new Set();
  // The following is a union of all peripheral names used across all parts.
  if (anyInstanceAssigned("SPI")) {
    hdrs.add("spi.h")
  }
  if (anyInstanceAssigned("UART") || anyInstanceAssigned("LPUART")) {
    hdrs.add("uart.h")
  }
  if (anyInstanceAssigned("TMR") || anyInstanceAssigned("LPTMR")) {
    hdrs.add("tmr.h")
  }
  if (anyInstanceAssigned("I2C")) {
    hdrs.add("i2c.h")
  }
  if (anyInstanceAssigned("WDT") || anyInstanceAssigned("LPWDT")) {
    hdrs.add("wdt.h")
  }
  if (anyInstanceAssigned("RTC")) {
    hdrs.add("rtc.h")
  }
  if (anyInstanceAssigned("ADC")) {
    hdrs.add("adc.h")
  }
  if (anyInstanceAssigned("USB") || anyInstanceAssigned("HPUSB") || anyInstanceAssigned("USBHS")) {
    hdrs.add("usb.h")
  }
  if (anyInstanceAssigned("ICC")) {
    hdrs.add("icc.h")
  }
  if (isSystemClockAnySet("LPM Mux")) {
    hdrs.add("lp.h")
  }
  if (anyInstanceAssigned("I2S")) {
    hdrs.add("i2s.h")
  }
  if (anyInstanceAssigned("TRNG")) {
    hdrs.add("trng.h")
  }
  if (anyInstanceAssigned("OWM")) {
    hdrs.add("owm.h")
  }
  hdrs.add("mxc_device.h")
  hdrs.add("mxc_sys.h")
  hdrs.add("stddef.h")
  return Array.from(hdrs).sort();
}
%>
<%~ include("@normalizeSoc", it) %>
<%~ include("@copyrightHeader", it) %>

<% for (const header of getHeaders()) { %>
#include <<%= header %>>
<% } %>
#include "<%= getProject().Secure ? "adi_soc_peripheral_init.h" : "soc_init.h" %>"

<%~ include("./" + it.cfsconfig.Soc.toLowerCase() + "/globals.c.eta", it); %>
int PinInit(void) {
<% if (it.cfsconfig.Pins.length > 0) { %>
  int result;

  /* Initialize all the used GPIO Ports.
  */
  result = MXC_GPIO_Init(<%_ = getGpioPorts().map(port => `MXC_GPIO_PORT_${port}`).join(' | ') %>);
  if (result != E_NO_ERROR) {
    return result;
  }

  MXC_GPIO_SetConfigLock(MXC_GPIO_CONFIG_UNLOCKED);
<%   for (const pin of it.cfsconfig.Pins) { %>
<%     const peri = getAssignedPeripheral(pin.Peripheral); %>
<%     const signal = peri?.Signals?.find(s => s.Name === pin.Signal); %>
<%     if (signal || (!getAssignedProjectForPin(pin) && isPrimaryProject())) { %>

  /* <%= getPin(pin).Label %> (<%= pin.Pin %>): assigned to <%= pin.Peripheral %>_<%= pin.Signal %>.
<%       if (signal?.Description) { %>
  ** This pin is used for <%= signal.Description %>.
<%       } %>
  */
  const mxc_gpio_cfg_t cfg_<%= sanitize_identifier(getPin(pin).Label.toLowerCase()) %> = {
    .port = MXC_<%=getPin(pin).GPIOName %>,
    .mask = MXC_GPIO_PIN_<%= getPin(pin).GPIOPin %>,
<%     if (getSignal(pin).PinMuxSlot) { %>
    .func = MXC_GPIO_FUNC_ALT<%= getSignal(pin).PinMuxSlot %>,
<%     } else { %>
    .func = MXC_GPIO_FUNC_<%= signal?.Config.MODE ?? "IN"%>,
<%     } %>
    .pad = MXC_GPIO_PAD_<%= signal?.Config.PS ? pull_map[signal.Config.PS] : "NONE"%>,
    .vssel = MXC_GPIO_VSSEL_<%= getVssel(pin, signal) %>,
    .drvstr = MXC_GPIO_DRVSTR_<%= signal?.Config.DS?.replace("SPEC", "") ?? "0" %> 
  };
  result = MXC_GPIO_Config(&cfg_<%= sanitize_identifier(getPin(pin).Label.toLowerCase()) %>);
  if (result != E_NO_ERROR) {
    return result;
  }
<%     } %>
<%   } %>
<% } else { %>
  /* Pin configuration in default state. */
<% } %>

  MXC_GPIO_SetConfigLock(MXC_GPIO_CONFIG_LOCKED);

  return E_NO_ERROR;
}

int PeripheralInit(void) {
  int result = E_NO_ERROR;

<% if (getProject().Secure) { %>
  result = PinInit();
  if (result != E_NO_ERROR) {
    return result;
  }

<% } %>
<%~ include("./" + it.msdkInflectionPoint(it.cfsconfig.Soc).toLowerCase() + "/peripherals.c.eta", it) %>
<% if (getAssignedPeripheral("CM4 SysTick")?.Config?.ENABLE == "TRUE") { %>
  result = SysTick_Config(<%= getAssignedPeripheral("CM4 SysTick").Config.TICKS_BETWEEN_INTS %>U);
  if (result != 0U) {
    return result;
  }

<% } %>
<% if (getAssignedPeripheral("CM33 SysTick (S)")?.Config?.ENABLE == "TRUE") { %>
  result = SysTick_Config(<%= getAssignedPeripheral("CM33 SysTick (S)").Config.TICKS_BETWEEN_INTS %>U);
  if (result != 0U) {
    return result;
  }

<% } %>
<% if (getAssignedPeripheral("CM33 SysTick (NS)")?.Config?.ENABLE == "TRUE") { %>
  result = SysTick_Config(<%= getAssignedPeripheral("CM33 SysTick (NS)").Config.TICKS_BETWEEN_INTS %>U);
  if (result != 0U) {
    return result;
  }

<% } %>

  return result;
}
